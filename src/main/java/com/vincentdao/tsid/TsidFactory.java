package com.vincentdao.tsid;

import java.security.SecureRandom;
import java.time.Instant;
import java.util.Objects;

/**
 * A TSID factory for generating {@link Tsid}. There are currently two configurations for the factory:
 * <ul>
 * <li> Node ID: Indicates the current machine/node/worker. As TSIDs can be generated by multiple instances in the
 *      system, it is crucial to clearly define each node with its ID to ensure safe generation (i.e., no collision).
 *      The default value is the current thread's ID where the call to obtain the factory instance occurs.
 * <li> Custom epoch: Specifies the epoch for calculating the timestamp. The default is the Unix epoch.
 * </ul>
 * Further explanations of these configurations can be found in the {@link Tsid} documentation.
 * <p>
 * A builder is available for configuring these options. Note that once the factory instance is created, it cannot be
 * modified. To reset the instance, use the {@code reset()} method.
 * <p>
 * This factory is thread-safe, and {@code generate()} is guaranteed to generate a unique TSID on the same node.
 * There is also a quick method for generating the TSID on-the-go, but it may introduce collisions, so using it for
 * generating TSIDs for storage in the database is not recommended.
 */
public final class TsidFactory {

    private static final SecureRandom RANDOMIZER = new SecureRandom();

    private static TsidFactory instance;

    public static Builder builder() {
        return new Builder();
    }

    public static TsidFactory instance() {
        if (Objects.isNull(instance)) {
            generateDefaultFactory();
        }
        return instance;
    }

    private static synchronized void generateDefaultFactory() {
        if (Objects.isNull(instance)) {
            instance = TsidFactory.builder()
                    .withEpoch()
                    .asDefault()
                    .withEpoch()
                    .asDefault()
                    .build();
        }
    }

    /**
     * Resets the factory instance.
     */
    public static synchronized void reset() {
        instance = null;
    }

    private final long node;
    private final long epoch;

    private long sequence;
    private long prevSequenceStart;
    private long prevTimestamp;

    private TsidFactory(Builder builder) {
        if (Objects.isNull(builder)) {
            throw new NullPointerException("Builder is null.");
        }
        long builderEpoch = builder.epoch;
        if (builderEpoch < 0 || Tsid.MAX_TIMESTAMP < builderEpoch) {
            throw new IllegalArgumentException(String
                    .format("Epoch must be between 0 and %d.", Tsid.MAX_TIMESTAMP));
        }
        this.epoch = builderEpoch;
        long builderNode = builder.node;
        if (builderNode < 0 || Tsid.MAX_NODE < builderNode) {
            throw new IllegalArgumentException(String.format("Node must be between 0 and %d.", Tsid.MAX_NODE));
        }
        this.node = builderNode;
        this.prevSequenceStart = -1;
    }

    public Tsid quickGenerate() {
        long randSequence = RANDOMIZER.nextInt((int) (Tsid.MAX_SEQUENCE + 1));
        return new Tsid(getUtcTimestamp(), node, randSequence);
    }

    public synchronized Tsid generate() {
        long currentTimestamp = getUtcTimestamp();
        if (currentTimestamp <= prevTimestamp) {
            currentTimestamp = prevTimestamp;
            if (++sequence > Tsid.MAX_SEQUENCE) {
                sequence = 0;
            }
            if (sequence == prevSequenceStart) {
                currentTimestamp++;
                sequence = prevSequenceStart = RANDOMIZER.nextInt((int) Tsid.MAX_SEQUENCE + 1);
            }
        } else {
            sequence = prevSequenceStart = RANDOMIZER.nextInt((int) Tsid.MAX_SEQUENCE + 1);
        }
        prevTimestamp = currentTimestamp;
        return new Tsid(currentTimestamp, node, sequence);
    }

    private long getUtcTimestamp() {
        return (Instant.now().toEpochMilli() - epoch);
    }

    public long getNode() {
        return node;
    }

    public long getEpoch() {
        return epoch;
    }

    public static class Builder {

        static final String NODE_PROP_NAME = "tsid.node";
        static final String NODE_ENV_NAME = "TSID_NODE";
        static final String EPOCH_PROP_NAME = "tsid.epoch";
        static final String EPOCH_ENV_NAME = "TSID_EPOCH";

        long epoch;
        long node;

        private Builder() {
        }

        public static final class NodeBuilder {

            private final Builder builder;

            private NodeBuilder(Builder builder) {
                this.builder = builder;
            }

            public Builder comesFromSystemOrDefault() {
                // Get the node value from the system properties
                Long nodeAsProperty = Builder.convertStringToLong(System.getProperty(NODE_PROP_NAME));
                if (Objects.nonNull(nodeAsProperty)) {
                    builder.node = nodeAsProperty;
                    return builder;
                }
                // Get the node value from the system environment
                Long nodeAsEnv = Builder.convertStringToLong(System.getenv(NODE_ENV_NAME));
                if (Objects.nonNull(nodeAsEnv)) {
                    builder.node = nodeAsEnv;
                    return builder;
                }
                // Else, the current thread's id will be the node value
                builder.node = Thread.currentThread().getId();
                return builder;
            }

            public Builder asDefault() {
                builder.node = Thread.currentThread().getId();
                return builder;
            }

            public Builder customizedAs(long customNode) {
                builder.node = customNode;
                return builder;
            }
        }

        public NodeBuilder withNode() {
            return new NodeBuilder(this);
        }

        public static final class EpochBuilder {

            private final Builder builder;

            private EpochBuilder(Builder builder) {
                this.builder = builder;
            }

            public Builder comesFromSystemOrDefault() {
                // Get the epoch value from the system properties
                Long epochAsProperty = convertStringToLong(System.getProperty(EPOCH_PROP_NAME));
                if (Objects.nonNull(epochAsProperty)) {
                    builder.epoch = epochAsProperty;
                    return builder;
                }
                // Get the epoch value from the system environment
                Long epochAsEnv = convertStringToLong(System.getenv(EPOCH_ENV_NAME));
                if (Objects.nonNull(epochAsEnv)) {
                    builder.epoch = epochAsEnv;
                    return builder;
                }
                // Else, the epoch will be Unix epoch
                builder.epoch = Instant.EPOCH.toEpochMilli();
                return builder;
            }

            public Builder asDefault() {
                builder.epoch = Instant.EPOCH.toEpochMilli();
                return builder;
            }

            public Builder customizedAs(long customEpoch) {
                builder.epoch = customEpoch;
                return builder;
            }
        }

        public EpochBuilder withEpoch() {
            return new EpochBuilder(this);
        }

        private static Long convertStringToLong(String value) {
            if (Objects.isNull(value) || value.trim().isEmpty()) {
                return null;
            }
            return Long.parseLong(value);
        }

        public TsidFactory build() {
            if (Objects.nonNull(instance)) {
                throw new IllegalStateException(
                        "Instance of factory has already been generated. Consider using 'reset()' method first.");
            }
            return assignToInstanceAndReturn(this);
        }

        private static synchronized TsidFactory assignToInstanceAndReturn(Builder builder) {
            if (Objects.isNull(instance)) {
                instance = new TsidFactory(builder);
                return instance;
            }
            throw new IllegalStateException(
                    "Race condition encountered. Consider generate the factory safely first.");
        }
    }
}
